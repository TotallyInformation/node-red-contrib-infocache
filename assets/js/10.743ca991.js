(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{201:function(e,t,o){"use strict";o.r(t);var n=o(0),s=Object(n.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("p",[e._v("NOTE: This document is outdated and needs to be reworked.")]),e._v(" "),o("p",[e._v("Each instance of the InfoCache node has the following settings available.")]),e._v(" "),o("p",[o("strong",[e._v("Note")]),e._v(" that no caching strategy can cover every requirement. If you need to handle different cache strategies, use multiple instances of this node.")]),e._v(" "),o("p",[o("strong",[o("code",[e._v("name")]),e._v(" (string, optional)")])]),e._v(" "),o("p",[e._v("Only used in the Node-RED admin UI.")]),e._v(" "),o("p",[o("strong",[o("code",[e._v("Client Id")]),e._v(" (string, optional='_socketId')")])]),e._v(" "),o("p",[e._v('If not specified, will default to the "_socketId" property on input control messages. When an input control message is received, if it has the specified property, cache operations will be for that client id only. The default is designed to work closely with '),o("a",{attrs:{href:"https://github.com/TotallyInformation/node-red-contrib-uibuilder",target:"_blank",rel:"noopener noreferrer"}},[e._v("uibuilder"),o("OutboundLink")],1),e._v(" which uses Socket.IO for dynamic communications between the server and the client.")]),e._v(" "),o("h3",{attrs:{id:"future-settings"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#future-settings"}},[e._v("#")]),e._v(" Future settings")]),e._v(" "),o("p",[e._v("These settings are planned for future releases.")]),e._v(" "),o("p",[o("strong",[o("code",[e._v("Retention Time")]),e._v(" (number, optional)")])]),e._v(" "),o("p",[e._v("If not empty, cached messages will only be retained for the number of "),o("em",[e._v("seconds")]),e._v(" input. This overrides the # messages to retain so if the number limit hasn't been reached but the time has, messages will be removed anyway.")]),e._v(" "),o("p",[o("strong",[o("code",[e._v("# Messages to retain")]),e._v(" (number, optional)")])]),e._v(" "),o("p",[e._v('The number of messages that will be retained (by topic if "Retain by Topic" is true). The oldest message will be dropped when a new message arrives once the limit is reached. The default is null which means that '),o("strong",[e._v("all")]),e._v(" messages will be retained and it is up to you to trim the size using the reset control messages.")]),e._v(" "),o("p",[o("strong",[e._v("WARNING")]),e._v(": If you let the cache get too large, it "),o("strong",[e._v("will")]),e._v(" crash Node-RED.")]),e._v(" "),o("p",[o("strong",[o("code",[e._v("Reset After Replay?")]),e._v(" (boolean, optional=false)")])]),e._v(" "),o("p",[e._v("Defaults to "),o("code",[e._v("false")]),e._v(". If "),o("code",[e._v("true")]),e._v(", the cache will be emptied after a replay event. "),o("em",[e._v("Note")]),e._v(" that this is only likely to be useful if you don't need to handle multiple clients. It saves having to have logic to send a reset control message if you always want to clear the cache after a replay.")]),e._v(" "),o("p",[o("strong",[o("code",[e._v("Storage Engine")]),e._v(" (dropdown)")])]),e._v(" "),o("p",[e._v('Allows the selection of the cache storage to be used. Initially only "Memory" will be available. Other pluggable engines may be produced. Please feel free to contribute one.')])])}),[],!1,null,null,null);t.default=s.exports}}]);